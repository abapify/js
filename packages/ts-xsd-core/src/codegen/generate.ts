/**
 * Schema Literal Generator
 * 
 * Transforms a parsed Schema object into a TypeScript literal string
 * that preserves type information for InferSchema<T>.
 */

import { parseXsd } from '../xsd';
import type { Schema } from '../xsd/types';

export interface GenerateOptions {
  /** Variable name for the exported schema */
  name?: string;
  /** Add JSDoc comment */
  comment?: string;
  /** Pretty print with indentation */
  pretty?: boolean;
  /** Indentation string (default: '  ') */
  indent?: string;
}

/**
 * Generate a TypeScript literal string from XSD content.
 * 
 * @param xsdContent - XSD file content as string
 * @param options - Generation options
 * @returns TypeScript code with schema as const literal
 * 
 * @example
 * ```typescript
 * const xsd = `<xs:schema>...</xs:schema>`;
 * const code = generateSchemaLiteral(xsd, { name: 'PersonSchema' });
 * // export const PersonSchema = { ... } as const;
 * ```
 */
export function generateSchemaLiteral(xsdContent: string, options: GenerateOptions = {}): string {
  const schema = parseXsd(xsdContent);
  return schemaToLiteral(schema, options);
}

/**
 * Generate a complete TypeScript file from XSD content.
 * 
 * @param xsdContent - XSD file content as string
 * @param options - Generation options
 * @returns Complete TypeScript file content
 */
export function generateSchemaFile(xsdContent: string, options: GenerateOptions = {}): string {
  const {
    name = 'schema',
    comment,
  } = options;

  const lines: string[] = [
    '/**',
    ' * Auto-generated schema literal from XSD',
    ' * ',
    ' * DO NOT EDIT - Generated by ts-xsd-core codegen',
    comment ? ` * ${comment}` : null,
    ' */',
    '',
    '// eslint-disable-next-line @typescript-eslint/no-unused-vars',
    `import type { SchemaLike } from '@abapify/ts-xsd-core';`,
    '',
    generateSchemaLiteral(xsdContent, options),
    '',
    `export type ${pascalCase(name)}Type = typeof ${name};`,
    '',
  ].filter((line): line is string => line !== null);

  return lines.join('\n');
}

/**
 * Convert a Schema object to a TypeScript literal string.
 */
function schemaToLiteral(schema: Schema, options: GenerateOptions = {}): string {
  const {
    name = 'schema',
    pretty = true,
    indent = '  ',
  } = options;

  const literal = objectToLiteral(schema, pretty, indent, 0);
  return `export const ${name} = ${literal} as const satisfies SchemaLike;`;
}

/**
 * Convert any value to a TypeScript literal string.
 */
function objectToLiteral(
  value: unknown,
  pretty: boolean,
  indent: string,
  depth: number
): string {
  if (value === null || value === undefined) {
    return 'undefined';
  }

  if (typeof value === 'string') {
    return JSON.stringify(value);
  }

  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value);
  }

  if (Array.isArray(value)) {
    if (value.length === 0) {
      return '[]';
    }

    const items = value.map(item => objectToLiteral(item, pretty, indent, depth + 1));
    
    if (pretty) {
      const itemIndent = indent.repeat(depth + 1);
      const closeIndent = indent.repeat(depth);
      return `[\n${items.map(item => `${itemIndent}${item}`).join(',\n')},\n${closeIndent}]`;
    }
    
    return `[${items.join(', ')}]`;
  }

  if (typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const entries = Object.entries(obj).filter(([, v]) => v !== undefined);
    
    if (entries.length === 0) {
      return '{}';
    }

    const props = entries.map(([key, val]) => {
      const keyStr = isValidIdentifier(key) ? key : JSON.stringify(key);
      const valStr = objectToLiteral(val, pretty, indent, depth + 1);
      return `${keyStr}: ${valStr}`;
    });

    if (pretty) {
      const propIndent = indent.repeat(depth + 1);
      const closeIndent = indent.repeat(depth);
      return `{\n${props.map(prop => `${propIndent}${prop}`).join(',\n')},\n${closeIndent}}`;
    }

    return `{ ${props.join(', ')} }`;
  }

  return 'undefined';
}

/**
 * Check if a string is a valid JavaScript identifier.
 */
function isValidIdentifier(str: string): boolean {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str);
}

/**
 * Convert string to PascalCase.
 */
function pascalCase(str: string): string {
  return str
    .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
    .replace(/^./, s => s.toUpperCase());
}
