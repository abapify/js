import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import {
  PluginRegistry,
  FormatPlugin,
  AdkObject,
  SerializeResult,
} from '../plugins';
import { ConfigLoader } from '../config/loader';
import { AuthRegistry } from '../config/auth';
import { CliConfig } from '../config/interfaces';
import fs from 'fs/promises';
import path from 'path';
import { tmpdir } from 'os';

/**
 * Mock OAT plugin for testing
 */
class MockOatPlugin implements FormatPlugin {
  readonly name = '@abapify/oat';
  readonly version = '1.0.0';
  readonly description = 'Mock OAT format plugin for testing';

  async serialize(
    objects: AdkObject[],
    targetPath: string
  ): Promise<SerializeResult> {
    const filesCreated: string[] = [];

    // Create target directory
    await fs.mkdir(targetPath, { recursive: true });

    // Serialize each object
    for (const obj of objects) {
      const fileName = `${obj.metadata.name.toLowerCase()}.${obj.kind.toLowerCase()}.yml`;
      const filePath = path.join(targetPath, fileName);

      const yamlContent = `kind: ${obj.kind}
metadata:
  name: ${obj.metadata.name}
  description: ${obj.metadata.description || ''}
  package: ${obj.metadata.package || ''}
spec: ${JSON.stringify(obj.spec, null, 2)}`;

      await fs.writeFile(filePath, yamlContent, 'utf-8');
      filesCreated.push(filePath);
    }

    return {
      success: true,
      filesCreated,
      objectsProcessed: objects.length,
      errors: [],
    };
  }

  async deserialize(sourcePath: string): Promise<AdkObject[]> {
    const objects: AdkObject[] = [];

    try {
      const files = await fs.readdir(sourcePath);
      const yamlFiles = files.filter(
        (f) => f.endsWith('.yml') || f.endsWith('.yaml')
      );

      for (const file of yamlFiles) {
        const filePath = path.join(sourcePath, file);
        const content = await fs.readFile(filePath, 'utf-8');

        // Simple YAML parsing for test
        const lines = content.split('\n');
        const kindLine = lines.find((l) => l.startsWith('kind:'));
        const nameLine = lines.find((l) => l.includes('name:'));

        if (kindLine && nameLine) {
          const kind = kindLine.split(':')[1].trim();
          const name = nameLine.split(':')[1].trim();

          objects.push({
            kind: kind as any,
            metadata: { name },
            spec: { mockData: true },
          });
        }
      }
    } catch (error) {
      // Return empty array if directory doesn't exist or other errors
    }

    return objects;
  }

  getSupportedObjectTypes(): string[] {
    return ['Class', 'Interface', 'Domain'];
  }

  validateConfig(): { valid: boolean; errors: string[]; warnings?: string[] } {
    return { valid: true, errors: [] };
  }
}

/**
 * Mock abapGit plugin for testing
 */
class MockAbapGitPlugin implements FormatPlugin {
  readonly name = '@abapify/abapgit';
  readonly version = '2.0.0';
  readonly description = 'Mock abapGit format plugin for testing';

  async serialize(
    objects: AdkObject[],
    targetPath: string
  ): Promise<SerializeResult> {
    const filesCreated: string[] = [];

    await fs.mkdir(path.join(targetPath, 'src'), { recursive: true });

    for (const obj of objects) {
      // Create .abap file
      const abapFile = path.join(
        targetPath,
        'src',
        `${obj.metadata.name.toLowerCase()}.${obj.kind.toLowerCase()}.abap`
      );
      await fs.writeFile(
        abapFile,
        `* ${obj.metadata.description}\n* Generated by abapGit plugin`,
        'utf-8'
      );
      filesCreated.push(abapFile);

      // Create .xml file
      const xmlFile = path.join(
        targetPath,
        'src',
        `${obj.metadata.name.toLowerCase()}.${obj.kind.toLowerCase()}.xml`
      );
      const xmlContent = `<?xml version="1.0" encoding="utf-8"?>
<abapGit version="v1.0.0">
  <asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0">
    <asx:values>
      <OBJECT_NAME>${obj.metadata.name}</OBJECT_NAME>
      <OBJECT_TYPE>${obj.kind}</OBJECT_TYPE>
    </asx:values>
  </asx:abap>
</abapGit>`;
      await fs.writeFile(xmlFile, xmlContent, 'utf-8');
      filesCreated.push(xmlFile);
    }

    return {
      success: true,
      filesCreated,
      objectsProcessed: objects.length,
      errors: [],
    };
  }

  async deserialize(sourcePath: string): Promise<AdkObject[]> {
    const objects: AdkObject[] = [];

    try {
      const srcPath = path.join(sourcePath, 'src');
      const files = await fs.readdir(srcPath);
      const xmlFiles = files.filter((f) => f.endsWith('.xml'));

      for (const file of xmlFiles) {
        const name = file.split('.')[0].toUpperCase();
        const kind = file.split('.')[1];

        objects.push({
          kind: kind as any,
          metadata: { name },
          spec: { abapGitFormat: true },
        });
      }
    } catch (error) {
      // Return empty array if directory doesn't exist
    }

    return objects;
  }

  getSupportedObjectTypes(): string[] {
    return ['Class', 'Interface', 'Program'];
  }

  validateConfig(): { valid: boolean; errors: string[]; warnings?: string[] } {
    return { valid: true, errors: [] };
  }
}

describe('Plugin Architecture E2E Tests', () => {
  let tempDir: string;
  let pluginRegistry: PluginRegistry;
  let configLoader: ConfigLoader;
  let authRegistry: AuthRegistry;

  beforeEach(async () => {
    // Create temporary directory for tests
    tempDir = await fs.mkdtemp(path.join(tmpdir(), 'adt-cli-test-'));

    // Initialize components
    pluginRegistry = new PluginRegistry();
    configLoader = new ConfigLoader();
    authRegistry = new AuthRegistry();

    // Register mock plugins manually for testing
    pluginRegistry.register(new MockOatPlugin());
    pluginRegistry.register(new MockAbapGitPlugin());
  });

  afterEach(async () => {
    // Clean up temporary directory
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  it('should load plugins from configuration', async () => {
    const config: CliConfig = {
      auth: {
        type: 'mock',
        mock: { enabled: true },
      },
      plugins: {
        formats: [{ name: '@abapify/oat' }, { name: '@abapify/abapgit' }],
      },
    };

    // Validate config
    const validation = configLoader.validate(config);
    expect(validation.valid).toBe(true);
    expect(validation.errors).toHaveLength(0);

    // Check available formats
    const formats = pluginRegistry.getAvailableFormats();
    expect(formats).toContain('@abapify/oat');
    expect(formats).toContain('@abapify/abapgit');
  });

  it('should serialize objects using OAT plugin', async () => {
    const plugin = pluginRegistry.getPlugin('@abapify/oat');
    expect(plugin).toBeDefined();

    const mockObjects: AdkObject[] = [
      {
        kind: 'Class' as any,
        metadata: {
          name: 'ZCL_TEST',
          description: 'Test class',
          package: 'ZTEST',
        },
        spec: {
          visibility: 'PUBLIC',
          methods: [],
        },
      },
    ];

    const outputPath = path.join(tempDir, 'oat-output');
    const result = await plugin!.serialize(mockObjects, outputPath);

    expect(result.success).toBe(true);
    expect(result.objectsProcessed).toBe(1);
    expect(result.filesCreated).toHaveLength(1);

    // Verify file was created
    const expectedFile = path.join(outputPath, 'zcl_test.class.yml');
    expect(result.filesCreated[0]).toBe(expectedFile);

    const fileExists = await fs
      .access(expectedFile)
      .then(() => true)
      .catch(() => false);
    expect(fileExists).toBe(true);

    // Verify file content
    const content = await fs.readFile(expectedFile, 'utf-8');
    expect(content).toContain('kind: Class');
    expect(content).toContain('name: ZCL_TEST');
    expect(content).toContain('package: ZTEST');
  });

  it('should serialize objects using abapGit plugin', async () => {
    const plugin = pluginRegistry.getPlugin('@abapify/abapgit');
    expect(plugin).toBeDefined();

    const mockObjects: AdkObject[] = [
      {
        kind: 'Interface' as any,
        metadata: {
          name: 'ZIF_TEST',
          description: 'Test interface',
        },
        spec: {
          methods: [],
        },
      },
    ];

    const outputPath = path.join(tempDir, 'abapgit-output');
    const result = await plugin!.serialize(mockObjects, outputPath);

    expect(result.success).toBe(true);
    expect(result.objectsProcessed).toBe(1);
    expect(result.filesCreated).toHaveLength(2); // .abap and .xml files

    // Verify files were created
    const abapFile = path.join(outputPath, 'src', 'zif_test.interface.abap');
    const xmlFile = path.join(outputPath, 'src', 'zif_test.interface.xml');

    expect(result.filesCreated).toContain(abapFile);
    expect(result.filesCreated).toContain(xmlFile);

    const abapExists = await fs
      .access(abapFile)
      .then(() => true)
      .catch(() => false);
    const xmlExists = await fs
      .access(xmlFile)
      .then(() => true)
      .catch(() => false);

    expect(abapExists).toBe(true);
    expect(xmlExists).toBe(true);
  });

  it('should deserialize objects from OAT format', async () => {
    const plugin = pluginRegistry.getPlugin('@abapify/oat');
    expect(plugin).toBeDefined();

    // First serialize some objects
    const mockObjects: AdkObject[] = [
      {
        kind: 'Domain' as any,
        metadata: {
          name: 'ZTEST_DOMAIN',
          description: 'Test domain',
        },
        spec: {
          datatype: 'CHAR',
          length: 10,
        },
      },
    ];

    const testPath = path.join(tempDir, 'oat-test');
    await plugin!.serialize(mockObjects, testPath);

    // Now deserialize
    const deserializedObjects = await plugin!.deserialize(testPath);

    expect(deserializedObjects).toHaveLength(1);
    expect(deserializedObjects[0].kind).toBe('Domain');
    expect(deserializedObjects[0].metadata.name).toBe('ZTEST_DOMAIN');
  });

  it('should handle multiple plugins with format selection', async () => {
    const config: CliConfig = {
      auth: {
        type: 'mock',
        mock: { enabled: true },
      },
      plugins: {
        formats: [{ name: '@abapify/oat' }, { name: '@abapify/abapgit' }],
      },
    };

    // Simulate CLI behavior: multiple plugins available, no default
    const availableFormats = pluginRegistry.getAvailableFormats();
    expect(availableFormats).toHaveLength(2);

    // User would be prompted to choose - simulate choosing OAT
    const selectedFormat = '@abapify/oat';
    const plugin = pluginRegistry.getPlugin(selectedFormat);
    expect(plugin).toBeDefined();
    expect(plugin!.name).toBe('@abapify/oat');
  });

  it('should handle default format from config', async () => {
    const config: CliConfig = {
      auth: {
        type: 'mock',
        mock: { enabled: true },
      },
      plugins: {
        formats: [{ name: '@abapify/oat' }, { name: '@abapify/abapgit' }],
      },
      defaults: {
        format: 'oat', // Default format specified
      },
    };

    const validation = configLoader.validate(config);
    expect(validation.valid).toBe(true);

    // CLI would use default format without prompting
    const defaultFormat = config.defaults?.format;
    expect(defaultFormat).toBe('oat');

    const plugin = pluginRegistry.getPlugin(`@abapify/${defaultFormat}`);
    expect(plugin).toBeDefined();
    expect(plugin!.name).toBe('@abapify/oat');
  });

  it('should validate plugin configurations', async () => {
    const config: CliConfig = {
      auth: {
        type: 'mock',
        mock: { enabled: true },
      },
      plugins: {
        formats: [
          {
            name: '@abapify/oat',
            config: {
              enabled: true,
              options: {
                fileStructure: 'hierarchical',
                includeMetadata: true,
              },
            },
          },
        ],
      },
    };

    const validation = configLoader.validate(config);
    expect(validation.valid).toBe(true);

    // Validate individual plugins
    const pluginValidations = pluginRegistry.validatePlugins();
    expect(pluginValidations).toHaveLength(2); // Both registered plugins
    expect(pluginValidations.every((v) => v.valid)).toBe(true);
  });

  it('should handle authentication configuration', async () => {
    const mockConfig: CliConfig = {
      auth: {
        type: 'mock',
        mock: { enabled: true },
      },
      plugins: {
        formats: [{ name: '@abapify/oat' }],
      },
    };

    const basicConfig: CliConfig = {
      auth: {
        type: 'basic',
        basic: {
          username: 'testuser',
          password: 'testpass',
          host: 'https://test-sap-system.com',
        },
      },
      plugins: {
        formats: [{ name: '@abapify/oat' }],
      },
    };

    // Validate mock auth
    const mockValidation = configLoader.validate(mockConfig);
    expect(mockValidation.valid).toBe(true);

    // Validate basic auth
    const basicValidation = configLoader.validate(basicConfig);
    expect(basicValidation.valid).toBe(true);

    // Test auth client creation
    const mockClient = await authRegistry.createClient(mockConfig.auth);
    expect(mockClient).toBeDefined();

    const basicClient = await authRegistry.createClient(basicConfig.auth);
    expect(basicClient).toBeDefined();
  });

  it('should handle configuration errors gracefully', async () => {
    const invalidConfig: CliConfig = {
      auth: {
        type: 'basic',
        basic: {
          username: '',
          password: '',
          host: 'invalid-url',
        },
      },
      plugins: {
        formats: [],
      },
    };

    const validation = configLoader.validate(invalidConfig);
    expect(validation.valid).toBe(false);
    expect(validation.errors).toContain('Username is required for basic auth');
    expect(validation.errors).toContain('Password is required for basic auth');
    expect(validation.errors).toContain(
      'At least one format plugin must be configured'
    );
  });

  it('should support plugin-specific options', async () => {
    const plugin = pluginRegistry.getPlugin('@abapify/oat');
    expect(plugin).toBeDefined();

    const supportedTypes = plugin!.getSupportedObjectTypes();
    expect(supportedTypes).toContain('Class');
    expect(supportedTypes).toContain('Interface');
    expect(supportedTypes).toContain('Domain');

    const abapGitPlugin = pluginRegistry.getPlugin('@abapify/abapgit');
    const abapGitTypes = abapGitPlugin!.getSupportedObjectTypes();
    expect(abapGitTypes).toContain('Program'); // Different from OAT
  });
});
