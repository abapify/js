/**
 * Types Generator - Extracts expanded TypeScript interfaces from schemas
 * 
 * Uses ts-morph to resolve InferXsd<Schema> into plain interfaces.
 * This solves TS7056 by pre-computing complex inferred types.
 * 
 * @example
 * ```typescript
 * import { defineConfig, factory, types } from 'ts-xsd';
 * 
 * export default defineConfig({
 *   generator: factory({ path: '../../speci' }),
 *   // Add types generator for .d.ts files
 *   typesGenerator: types(),
 * });
 * ```
 */

import { Project, type SourceFile, type Type } from 'ts-morph';

/**
 * Options for the types generator
 */
export interface TypesOptions {
  /**
   * Name suffix for the exported type
   * @default 'Data'
   */
  typeSuffix?: string;
  
  /**
   * Path to factory function for wrapping schemas
   * When provided, generates .types.ts with wrapped export instead of .d.ts
   * @example '../../../speci'
   */
  factoryPath?: string;
}

/**
 * Result of type extraction
 */
export interface ExtractedTypes {
  /** Generated .d.ts content */
  content: string;
  /** Type name that was exported */
  typeName: string;
}

/**
 * Types generator instance
 */
export interface TypesGenerator {
  /**
   * Extract types from a generated schema file
   * @param schemaPath Path to the generated .ts schema file
   * @param schemaName Name of the schema (e.g., 'adtcore')
   */
  extract(schemaPath: string, schemaName: string): ExtractedTypes | null;
  
  /**
   * Initialize the generator with a tsconfig
   * Must be called before extract()
   */
  init(tsConfigPath: string): void;
}

/**
 * Create a types generator
 */
export function types(options: TypesOptions = {}): TypesGenerator {
  const typeSuffix = options.typeSuffix ?? 'Data';
  const factoryPath = options.factoryPath;
  let project: Project | null = null;

  return {
    init(tsConfigPath: string) {
      project = new Project({
        tsConfigFilePath: tsConfigPath,
        skipAddingFilesFromTsConfig: false, // Load all files for type resolution
      });
    },

    extract(schemaPath: string, schemaName: string): ExtractedTypes | null {
      if (!project) {
        throw new Error('TypesGenerator not initialized. Call init() first.');
      }

      // Add or get the schema file
      let sourceFile = project.getSourceFile(schemaPath);
      if (!sourceFile) {
        sourceFile = project.addSourceFileAtPath(schemaPath);
      }

      // Get the default export (the schema)
      const defaultExport = sourceFile.getDefaultExportSymbol();
      if (!defaultExport) {
        return null;
      }

      // Create a temp file with a type alias to force type resolution
      // Use InferXsdMerged - it's Partial<intersection> which gives all properties merged
      const typeName = toPascalCase(schemaName) + typeSuffix;
      const tempCode = `
import schema from '${schemaPath.replace(/\.ts$/, '')}';
import type { InferXsdMerged } from 'ts-xsd';
export type ${typeName} = InferXsdMerged<typeof schema>;
declare const __data__: ${typeName};
`;

      const tempFile = project.createSourceFile('__temp_extract__.ts', tempCode, { overwrite: true });
      
      // Get the type from the variable (forces instantiation)
      const dataVar = tempFile.getVariableDeclarationOrThrow('__data__');
      const dataType = dataVar.getType();

      // Generate the interface
      const interfaceCode = generateInterface(typeName, dataType, tempFile);
      
      // Clean up temp file
      tempFile.delete();

      // Generate content - either .d.ts or .types.ts with wrapped export
      let content: string;
      
      if (factoryPath) {
        // Generate .types.ts with interface + wrapped export
        content = `/**
 * Auto-generated types for ${schemaName} schema
 * Generated by ts-xsd type extraction
 * 
 * DO NOT EDIT - This file is generated from the schema definition.
 */

import _schema from './${schemaName}.schema';
import wrap from '${factoryPath}';

${interfaceCode}

export default wrap<typeof _schema, ${typeName}>(_schema);
`;
      } else {
        // Generate .d.ts (legacy mode)
        content = `/**
 * Auto-generated type definitions for ${schemaName} schema
 * Generated by ts-xsd type extraction
 * 
 * DO NOT EDIT - This file is generated from the schema definition.
 * To regenerate: npx ts-xsd codegen --extract-types
 */

${interfaceCode}
`;
      }

      return { content, typeName };
    },
  };
}

/**
 * Convert kebab-case to PascalCase
 */
function toPascalCase(name: string): string {
  return name
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

/**
 * Generate interface code from a resolved type
 */
function generateInterface(name: string, type: Type, sourceFile: SourceFile): string {
  const lines: string[] = [];
  lines.push(`export interface ${name} {`);
  
  // For intersection types (like Partial<A & B>), getApparentProperties works
  const props = type.getApparentProperties();
  
  
  for (const prop of props) {
    const propType = prop.getTypeAtLocation(sourceFile);
    const opt = prop.isOptional() ? '?' : '';
    const typeStr = expandType(propType, sourceFile, 1);
    lines.push(`  ${prop.getName()}${opt}: ${typeStr};`);
  }
  
  lines.push('}');
  return lines.join('\n');
}

/**
 * Expand a type to its string representation
 */
function expandType(type: Type, sourceFile: SourceFile, depth: number, path: string[] = []): string {
  if (depth > 10) {
    return 'unknown';
  }

  // Primitives
  if (type.isString()) return 'string';
  if (type.isNumber()) return 'number';
  if (type.isBoolean()) return 'boolean';
  if (type.isNull()) return 'null';
  if (type.isUndefined()) return 'undefined';
  if (type.isAny()) return 'any';
  if (type.isUnknown()) return 'unknown';
  if (type.isNever()) return 'never';

  // Date
  const symbol = type.getSymbol();
  if (symbol?.getName() === 'Date') return 'Date';

  // String/number literals
  if (type.isStringLiteral()) return type.getText();
  if (type.isNumberLiteral()) return type.getText();

  // Unions - handle BEFORE arrays since optional arrays are unions (T[] | undefined)
  if (type.isUnion()) {
    const types = type.getUnionTypes();
    // Filter out undefined for optional handling
    const nonUndefined = types.filter(t => !t.isUndefined());
    if (nonUndefined.length === 0) return 'undefined';
    if (nonUndefined.length === 1) {
      // Single non-undefined type - expand it (handles optional arrays)
      return expandType(nonUndefined[0], sourceFile, depth + 1, [...path, '[union]']);
    }
    // Check for boolean literal union
    if (nonUndefined.length === 2 && nonUndefined.every(t => t.isBooleanLiteral())) {
      return 'boolean';
    }
    return nonUndefined.map((t, i) => expandType(t, sourceFile, depth + 1, [...path, `[union${i}]`])).join(' | ');
  }

  // Arrays
  if (type.isArray()) {
    const elem = type.getArrayElementType();
    if (elem) {
      // For array elements with properties, expand them inline
      const elemProps = elem.getApparentProperties();
      if (elemProps.length > 0) {
        const elemStr = expandType(elem, sourceFile, depth + 1, [...path, '[]']);
        return `(${elemStr})[]`;
      }
      const elemStr = expandType(elem, sourceFile, depth + 1, [...path, '[]']);
      // Wrap complex types in parentheses
      if (elemStr.includes('|') || elemStr.includes('{')) {
        return `(${elemStr})[]`;
      }
      return `${elemStr}[]`;
    }
    return 'unknown[]';
  }

  // Skip Function types - they have infinite recursive properties (apply, call, bind, toString...)
  const typeSymbol = type.getSymbol();
  const symbolName = typeSymbol?.getName();
  if (symbolName === 'Function' || symbolName === 'CallableFunction' || symbolName === 'NewableFunction') {
    return 'Function';
  }

  // Built-in properties to skip (Function/Object prototype methods)
  const builtinProps = new Set([
    'toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf',
    'propertyIsEnumerable', 'constructor', '__proto__', '__defineGetter__',
    '__defineSetter__', '__lookupGetter__', '__lookupSetter__',
    'apply', 'call', 'bind', 'arguments', 'caller', 'prototype', 'length', 'name',
  ]);

  // Objects with properties - check getApparentProperties first since isObject() 
  // can return false for complex type aliases that still have properties
  const props = type.getApparentProperties();
  // Filter out built-in properties
  const userProps = props.filter(p => !builtinProps.has(p.getName()) && !p.getName().startsWith('__@'));
  if (userProps.length > 0) {
    const indent = '  '.repeat(depth + 1);
    const closeIndent = '  '.repeat(depth);
    const propLines: string[] = [];
    
    for (const prop of userProps) {
      const propType = prop.getTypeAtLocation(sourceFile);
      const opt = prop.isOptional() ? '?' : '';
      const typeStr = expandType(propType, sourceFile, depth + 1, [...path, prop.getName()]);
      propLines.push(`${indent}${prop.getName()}${opt}: ${typeStr};`);
    }
    
    return `{\n${propLines.join('\n')}\n${closeIndent}}`;
  }

  // Empty object
  if (type.isObject()) {
    return '{}';
  }

  // Fallback: use getText with enclosing node for expansion
  return type.getText(sourceFile);
}

export default types;
