/**
 * Interfaces Generator
 * 
 * Generates TypeScript interfaces from XSD schemas using ts-morph.
 * This wraps the existing interface-generator.ts implementation.
 * 
 * Output: `export interface TypeName { ... }`
 */

import type { GeneratorPlugin, TransformContext, GeneratedFile } from '../codegen/types';
import { generateInterfacesWithDeps } from '../codegen/interface-generator';
import type { GeneratorOptions } from '../codegen/interface-generator';

// ============================================================================
// Options
// ============================================================================

export interface InterfacesOptions extends GeneratorOptions {
  /** Output file name pattern. Use {name} for schema name (default: '{name}.types.ts') */
  filePattern?: string;
  /** Add file header comment */
  header?: boolean;
}

// ============================================================================
// Generator
// ============================================================================

/**
 * Create an interfaces generator plugin
 * 
 * Generates TypeScript interfaces from XSD complex types.
 * This solves the TS2589 "Type instantiation is excessively deep" problem
 * by generating interfaces at build time instead of relying on compile-time inference.
 * 
 * @example
 * ```ts
 * import { rawSchema, interfaces, indexBarrel } from 'ts-xsd/generators';
 * 
 * export default defineConfig({
 *   generators: [
 *     rawSchema(),
 *     interfaces({ generateAllTypes: true }),  // Generate all complex types
 *     indexBarrel(),
 *   ],
 * });
 * ```
 */
export function interfaces(options: InterfacesOptions = {}): GeneratorPlugin {
  const {
    filePattern = '{name}.types.ts',
    header = true,
    ...generatorOptions
  } = options;

  return {
    name: 'interfaces',

    transform(ctx: TransformContext): GeneratedFile[] {
      const { schema, source } = ctx;
      
      // Use the core generator with dependency tracking
      const result = generateInterfacesWithDeps(schema.schema, {
        generateAllTypes: true,  // Default to generating all types
        addJsDoc: true,
        ...generatorOptions,
      });

      // Build output
      const lines: string[] = [];

      // Header
      if (header) {
        lines.push(
          '/**',
          ' * Auto-generated TypeScript interfaces from XSD',
          ' * ',
          ' * DO NOT EDIT - Generated by ts-xsd codegen',
          ` * Source: ${source.name}/${schema.name}.xsd`,
          ' */',
          '',
        );
      }

      // Add imports for external types
      // Map namespace URIs to schema names using import declarations
      const imports = schema.schema.import;
      
      if (result.externalTypes.size > 0) {
        // Build a map from namespace URI to schema filename
        const nsToSchemaFile = new Map<string, string>();
        
        if (imports && Array.isArray(imports)) {
          for (const imp of imports) {
            if (imp.namespace && imp.schemaLocation) {
              // Extract filename without extension from schemaLocation
              const schemaFile = imp.schemaLocation.replace(/\.xsd$/, '');
              nsToSchemaFile.set(imp.namespace, schemaFile);
            }
          }
        }
        
        // Group external types by their source schema file
        const typesByFile = new Map<string, string[]>();
        
        for (const [namespace, types] of result.externalTypes) {
          // Find the schema file for this namespace
          const schemaFile = nsToSchemaFile.get(namespace);
          if (schemaFile && types.length > 0) {
            const existing = typesByFile.get(schemaFile) || [];
            typesByFile.set(schemaFile, [...existing, ...types]);
          }
        }
        
        // Generate import statements
        for (const [schemaFile, types] of typesByFile) {
          const uniqueTypes = [...new Set(types)].sort();
          lines.push(`import type { ${uniqueTypes.join(', ')} } from './${schemaFile}.types';`);
        }
        
        if (typesByFile.size > 0) {
          lines.push('');
        }
      }

      lines.push(result.code);

      const fileName = filePattern.replace('{name}', schema.name);

      return [{
        path: fileName,
        content: lines.join('\n'),
      }];
    },
  };
}
