/**
 * Interfaces Generator
 * 
 * Generates TypeScript interfaces from XSD schemas using ts-morph.
 * This wraps the existing interface-generator.ts implementation.
 * 
 * Output: `export interface TypeName { ... }`
 */

import type { GeneratorPlugin, TransformContext, GeneratedFile, SchemaInfo } from '../codegen/types';
import { generateInterfacesWithDeps } from '../codegen/interface-generator';
import type { GeneratorOptions } from '../codegen/interface-generator';
import type { Schema } from '../xsd/types';

// ============================================================================
// Options
// ============================================================================

export interface InterfacesOptions extends GeneratorOptions {
  /** Output file name pattern. Use {name} for schema name, {source} for source name (default: '{name}.types.ts') */
  filePattern?: string;
  /** Import path pattern for cross-schema type imports. Use {name} for schema name (default: './{name}.types') */
  importPattern?: string;
  /** Add file header comment */
  header?: boolean;
}

// ============================================================================
// Generator
// ============================================================================

/**
 * Create an interfaces generator plugin
 * 
 * Generates TypeScript interfaces from XSD complex types.
 * This solves the TS2589 "Type instantiation is excessively deep" problem
 * by generating interfaces at build time instead of relying on compile-time inference.
 * 
 * @example
 * ```ts
 * import { rawSchema, interfaces, indexBarrel } from 'ts-xsd/generators';
 * 
 * export default defineConfig({
 *   generators: [
 *     rawSchema(),
 *     interfaces({ generateAllTypes: true }),  // Generate all complex types
 *     indexBarrel(),
 *   ],
 * });
 * ```
 */
export function interfaces(options: InterfacesOptions = {}): GeneratorPlugin {
  const {
    filePattern = '{name}.types.ts',
    // importPattern is no longer used - we calculate paths based on source
    importPattern: _importPattern = './{name}.types',
    header = true,
    ...generatorOptions
  } = options;

  return {
    name: 'interfaces',

    transform(ctx: TransformContext): GeneratedFile[] {
      const { schema, source, allSchemas } = ctx;
      
      // Link schemas: resolve $imports from allSchemas (includes ALL sources)
      const linkedSchema = linkSchemaImports(schema.schema, allSchemas, schema.name);
      
      // Use the core generator with dependency tracking
      const result = generateInterfacesWithDeps(linkedSchema, {
        generateAllTypes: true,  // Default to generating all types
        addJsDoc: true,
        ...generatorOptions,
      });

      // Build output
      const lines: string[] = [];

      // Header
      if (header) {
        lines.push(
          '/**',
          ' * Auto-generated TypeScript interfaces from XSD',
          ' * ',
          ' * DO NOT EDIT - Generated by ts-xsd codegen',
          ` * Source: ${source.name}/${schema.name}.xsd`,
          ' */',
          '',
        );
      }

      // Add imports for external types
      // Build a comprehensive map from $filename to schema info (name + source)
      // This handles cases where multiple schemas share the same targetNamespace
      if (result.externalTypes.size > 0) {
        // Build schema key â†’ schema info mapping
        // Keys can be $filename (e.g., "atomExtended.xsd") or namespace (fallback)
        const keyToSchemaInfo = new Map<string, { name: string; sourceName: string }>();
        
        for (const [schemaName, schemaInfo] of allSchemas) {
          // Primary key: $filename (matches schemaLocation in XSD import)
          const filename = (schemaInfo.schema as { $filename?: string }).$filename;
          if (filename) {
            keyToSchemaInfo.set(filename, { name: schemaName, sourceName: schemaInfo.sourceName });
          }
          // Fallback key: namespace (for schemas without $filename)
          const ns = schemaInfo.schema.targetNamespace;
          if (ns && !keyToSchemaInfo.has(ns)) {
            keyToSchemaInfo.set(ns, { name: schemaName, sourceName: schemaInfo.sourceName });
          }
        }
        
        // Group external types by their source schema
        const typesBySchema = new Map<string, { types: string[]; sourceName: string }>();
        
        for (const [schemaKey, types] of result.externalTypes) {
          if (types.length === 0) continue;
          
          // Find the schema for this key ($filename or namespace)
          const schemaInfo = keyToSchemaInfo.get(schemaKey);
          if (schemaInfo) {
            const key = `${schemaInfo.sourceName}/${schemaInfo.name}`;
            const existing = typesBySchema.get(key);
            if (existing) {
              existing.types.push(...types);
            } else {
              typesBySchema.set(key, { types: [...types], sourceName: schemaInfo.sourceName });
            }
          }
        }
        
        // Generate import statements with correct relative paths
        // Track already imported types to avoid duplicates across schemas
        const importedTypes = new Set<string>();
        
        // Filter to only types actually used in the generated code
        const generatedCode = result.code;
        
        for (const [schemaKey, { types, sourceName }] of typesBySchema) {
          // Filter out types already imported from another schema
          // AND filter out types not actually used in the generated code
          const newTypes = types.filter(t => 
            !importedTypes.has(t) && 
            // Check if type is actually used (as a type reference, not just in comments)
            new RegExp(`:\\s*${t}[\\[\\];,\\s]|extends\\s+${t}[\\s{<]`).test(generatedCode)
          );
          if (newTypes.length === 0) continue;
          
          const uniqueTypes = [...new Set(newTypes)].sort();
          uniqueTypes.forEach(t => importedTypes.add(t));
          
          const schemaName = schemaKey.split('/')[1];
          
          // Calculate relative path based on source
          let importPath: string;
          if (sourceName === source.name) {
            // Same source - use simple relative path
            importPath = `./${schemaName}.types`;
          } else {
            // Different source - need to go up and into other source
            importPath = `../${sourceName}/${schemaName}.types`;
          }
          
          lines.push(`import type { ${uniqueTypes.join(', ')} } from '${importPath}';`);
        }
        
        if (typesBySchema.size > 0) {
          lines.push('');
        }
      }

      lines.push(result.code);

      // Add substitution values interfaces and specialized interfaces
      // e.g., interface DomaValuesType { DD01V: Dd01vType; DD07V_TAB?: Dd07vTabType; }
      //       interface AbapGitDoma { abap: { values: DomaValuesType; version?: string; }; ... }
      // NOTE: Substitution aliases removed - was hardcoded ABAP XML structure
      // that doesn't belong in a generic XSD interface generator.
      // If substitution group support is needed, it should be done properly
      // based on XSD substitutionGroup semantics, not domain-specific structure.

      const fileName = filePattern
        .replace('{name}', schema.name)
        .replace('{source}', source.name);

      return [{
        path: fileName,
        content: lines.join('\n'),
      }];
    },
  };
}

// ============================================================================
// Helpers
// ============================================================================

/**
 * Link schema imports by resolving schemaLocation references to actual schema objects.
 * Also includes ALL schemas as $imports so substitution groups can be resolved
 * across the entire schema set (not just direct imports).
 * 
 * This is necessary because substitution groups work in reverse:
 * - asx.xsd defines abstract element Schema
 * - doma.xsd imports asx.xsd and defines DD01V substituting for Schema
 * - When generating asx.types.ts, we need to know about DD01V from doma.xsd
 */
function linkSchemaImports(
  schema: Schema,
  allSchemas: Map<string, SchemaInfo>,
  schemaName: string
): Schema {
  // Create a flat list of all schemas with $filename set
  // These schemas do NOT have $imports set to avoid circular references
  // The walker will only search one level deep
  const $imports: Schema[] = [];
  
  for (const [name, schemaInfo] of allSchemas) {
    // Skip self-reference
    if (schemaInfo.schema === schema) continue;
    // Create a copy with $filename set but NO $imports to prevent recursion
    $imports.push({
      ...schemaInfo.schema,
      $filename: schemaInfo.schema.$filename ?? `${name}.xsd`,
      $imports: undefined, // Explicitly clear to prevent recursion
    });
  }

  // Return schema with $imports populated and $filename set
  return {
    ...schema,
    $imports,
    $filename: schema.$filename ?? `${schemaName}.xsd`,
  };
}
