/**
 * Raw Schema Generator
 * 
 * Generates raw schema literals with `as const` for type inference.
 * 
 * Output: `export default { ... } as const;`
 */

import type { GeneratorPlugin, TransformContext, GeneratedFile } from '../codegen/types';

// ============================================================================
// Options
// ============================================================================

export interface RawSchemaOptions {
  /** Use default export (default: true) */
  defaultExport?: boolean;
  /** Use named export with this name (alternative to default export) */
  namedExport?: string;
  /** Include $xmlns in output (default: true) */
  $xmlns?: boolean;
  /** Include $imports in output (default: true) */
  $imports?: boolean;
  /** Include $filename in output (default: false) */
  $filename?: boolean;
  /** Properties to exclude from output */
  exclude?: string[];
  /** Add file header comment */
  header?: boolean;
}

// ============================================================================
// Generator
// ============================================================================

/**
 * Create a raw schema generator plugin
 * 
 * @example
 * ```ts
 * import { rawSchema } from 'ts-xsd/generators';
 * 
 * export default defineConfig({
 *   generators: [
 *     rawSchema(),  // default export
 *     rawSchema({ namedExport: 'mySchema' }),  // named export
 *   ],
 * });
 * ```
 */
export function rawSchema(options: RawSchemaOptions = {}): GeneratorPlugin {
  const {
    defaultExport = true,
    namedExport,
    $xmlns = true,
    $imports = true,
    $filename = false,
    exclude = ['annotation'],
    header = true,
  } = options;

  return {
    name: 'raw-schema',

    transform(ctx: TransformContext): GeneratedFile[] {
      const { schema, source } = ctx;
      const outputSchema = buildOutputSchema(schema.schema, {
        $xmlns,
        $imports,
        $filename,
        exclude,
        schemaName: schema.name,
        resolveImport: ctx.resolveImport,
      });

      const lines: string[] = [];

      // Header
      if (header) {
        lines.push(
          '/**',
          ' * Auto-generated schema from XSD',
          ' * ',
          ' * DO NOT EDIT - Generated by ts-xsd codegen',
          ` * Source: ${source.name}/${schema.name}.xsd`,
          ' */',
          '',
        );
      }

      // Imports for $imports
      const imports = getSchemaImports(schema.schema, ctx.resolveImport);
      if (imports.length > 0) {
        for (const imp of imports) {
          lines.push(`import ${imp.name} from '${imp.path}';`);
        }
        lines.push('');
      }

      // Schema literal
      const literal = objectToLiteral(outputSchema, true, '  ', 0);
      
      if (namedExport) {
        lines.push(`export const ${namedExport} = ${literal} as const;`);
      } else if (defaultExport) {
        lines.push(`export default ${literal} as const;`);
      }

      lines.push('');

      return [{
        path: `${schema.name}.ts`,
        content: lines.join('\n'),
      }];
    },
  };
}

// ============================================================================
// Helpers
// ============================================================================

interface BuildOptions {
  $xmlns: boolean;
  $imports: boolean;
  $filename: boolean;
  exclude: string[];
  schemaName: string;
  resolveImport: (schemaLocation: string) => string | null;
}

function buildOutputSchema(
  schema: Record<string, unknown>,
  options: BuildOptions
): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  const excludeSet = new Set(options.exclude);

  // Add $xmlns first if enabled
  if (options.$xmlns && schema.$xmlns) {
    result.$xmlns = schema.$xmlns;
  }

  // Add $imports if enabled (from both import and include)
  if (options.$imports) {
    const importRefs: SchemaRef[] = [];
    
    // Handle xs:import
    if (schema.import) {
      const imports = schema.import as Array<{ schemaLocation?: string }>;
      for (const imp of imports) {
        if (imp.schemaLocation) {
          const resolved = options.resolveImport(imp.schemaLocation);
          if (resolved) {
            const name = imp.schemaLocation.replace(/\.xsd$/, '').replace(/^.*\//, '');
            importRefs.push(new SchemaRef(name));
          }
        }
      }
    }
    
    // Handle xs:include (same namespace, different file)
    if (schema.include) {
      const includes = schema.include as Array<{ schemaLocation?: string }>;
      for (const inc of includes) {
        if (inc.schemaLocation) {
          const resolved = options.resolveImport(inc.schemaLocation);
          if (resolved) {
            const name = inc.schemaLocation.replace(/\.xsd$/, '').replace(/^.*\//, '');
            importRefs.push(new SchemaRef(name));
          }
        }
      }
    }
    
    if (importRefs.length > 0) {
      result.$imports = importRefs;
    }
  }

  // Add $filename if enabled
  if (options.$filename) {
    result.$filename = `${options.schemaName}.xsd`;
  }

  // Copy remaining properties (excluding 'import' which is handled above)
  for (const [key, value] of Object.entries(schema)) {
    if (key === '$xmlns' || key === 'import' || key === '$imports' || key === '$filename') {
      continue;
    }
    if (!excludeSet.has(key)) {
      result[key] = filterDeep(value, excludeSet);
    }
  }

  return result;
}

function getSchemaImports(
  schema: Record<string, unknown>,
  resolveImport: (schemaLocation: string) => string | null
): Array<{ name: string; path: string }> {
  const imports: Array<{ name: string; path: string }> = [];
  
  // Handle xs:import
  const xsdImports = schema.import as Array<{ schemaLocation?: string }> | undefined;
  if (xsdImports) {
    for (const imp of xsdImports) {
      if (imp.schemaLocation) {
        const modulePath = resolveImport(imp.schemaLocation);
        if (modulePath) {
          const name = imp.schemaLocation.replace(/\.xsd$/, '').replace(/^.*\//, '');
          imports.push({ name, path: modulePath });
        }
      }
    }
  }
  
  // Handle xs:include
  const xsdIncludes = schema.include as Array<{ schemaLocation?: string }> | undefined;
  if (xsdIncludes) {
    for (const inc of xsdIncludes) {
      if (inc.schemaLocation) {
        const modulePath = resolveImport(inc.schemaLocation);
        if (modulePath) {
          const name = inc.schemaLocation.replace(/\.xsd$/, '').replace(/^.*\//, '');
          imports.push({ name, path: modulePath });
        }
      }
    }
  }

  return imports;
}

/** Marker class for schema references in $imports */
class SchemaRef {
  constructor(public readonly name: string) {}
}

function filterDeep(value: unknown, exclude: Set<string>): unknown {
  if (value instanceof SchemaRef) {
    return value;
  }
  
  if (Array.isArray(value)) {
    return value.map(item => filterDeep(item, exclude));
  }
  
  if (value !== null && typeof value === 'object') {
    const result: Record<string, unknown> = {};
    for (const [k, v] of Object.entries(value)) {
      if (!exclude.has(k)) {
        result[k] = filterDeep(v, exclude);
      }
    }
    return result;
  }
  
  return value;
}

function objectToLiteral(value: unknown, pretty: boolean, indent: string, depth: number): string {
  if (value === null || value === undefined) {
    return 'undefined';
  }

  if (value instanceof SchemaRef) {
    return value.name;
  }

  if (typeof value === 'string') {
    return JSON.stringify(value);
  }

  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value);
  }

  if (Array.isArray(value)) {
    if (value.length === 0) return '[]';
    
    const items = value.map(item => objectToLiteral(item, pretty, indent, depth + 1));
    
    if (pretty) {
      const itemIndent = indent.repeat(depth + 1);
      const closeIndent = indent.repeat(depth);
      return `[\n${items.map(item => `${itemIndent}${item}`).join(',\n')},\n${closeIndent}]`;
    }
    
    return `[${items.join(', ')}]`;
  }

  if (typeof value === 'object') {
    const obj = value as Record<string, unknown>;
    const entries = Object.entries(obj).filter(([, v]) => v !== undefined);
    
    if (entries.length === 0) return '{}';

    const props = entries.map(([key, val]) => {
      const keyStr = isValidIdentifier(key) ? key : JSON.stringify(key);
      const valStr = objectToLiteral(val, pretty, indent, depth + 1);
      return `${keyStr}: ${valStr}`;
    });

    if (pretty) {
      const propIndent = indent.repeat(depth + 1);
      const closeIndent = indent.repeat(depth);
      return `{\n${props.map(prop => `${propIndent}${prop}`).join(',\n')},\n${closeIndent}}`;
    }

    return `{ ${props.join(', ')} }`;
  }

  return 'undefined';
}

const RESERVED_WORDS = new Set([
  'break', 'case', 'catch', 'continue', 'debugger', 'default', 'delete',
  'do', 'else', 'finally', 'for', 'function', 'if', 'in', 'instanceof',
  'new', 'return', 'switch', 'this', 'throw', 'try', 'typeof', 'var',
  'void', 'while', 'with', 'class', 'const', 'enum', 'export', 'extends',
  'import', 'super', 'implements', 'interface', 'let', 'package', 'private',
  'protected', 'public', 'static', 'yield', 'await', 'null', 'true', 'false',
]);

function isValidIdentifier(str: string): boolean {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str) && !RESERVED_WORDS.has(str);
}
