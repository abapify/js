/**
 * ts-xsd Code Generator
 *
 * Generate TypeScript schema files from XSD
 * 
 * Structure:
 * - xs/schema.ts   - xs:schema parsing
 * - xs/types.ts    - xs:simpleType / type mapping
 * - xs/element.ts  - xs:element handling
 * - xs/attribute.ts - xs:attribute handling
 * - xs/sequence.ts - xs:sequence / xs:choice handling
 */

export type { CodegenOptions, GeneratedSchema, ImportResolver } from './types';
import type { CodegenOptions, GeneratedSchema, ImportResolver } from './types';
import { parseSchema } from './xs/schema';
import { generateElementObj, generateElementDef } from './xs/sequence';

/**
 * Default resolver - just strips .xsd extension
 */
const defaultResolver: ImportResolver = (schemaLocation) => {
  return schemaLocation.replace(/\.xsd$/, '');
};

/**
 * Generate ts-xsd schema from XSD string
 */
export function generateFromXsd(xsd: string, options: CodegenOptions = {}): GeneratedSchema {
  const { targetNs, prefix, complexTypes, simpleTypes, rootElement, imports } = parseSchema(xsd, options);

  // Generate code
  const lines: string[] = [];

  // Header
  lines.push('/**');
  lines.push(' * Auto-generated ts-xsd schema');
  if (targetNs) {
    lines.push(` * Namespace: ${targetNs}`);
  }
  if (imports.length > 0) {
    lines.push(` * Imports: ${imports.map(i => i.schemaLocation).join(', ')}`);
  }
  lines.push(' * Generated by ts-xsd');
  lines.push(' */');
  lines.push('');
  lines.push("import type { XsdSchema } from 'ts-xsd';");
  
  // Generate imports for xsd:import dependencies
  const resolver = options.resolver || defaultResolver;
  const importNames: string[] = [];
  for (const imp of imports) {
    // Use resolver to transform schemaLocation to import path
    const importPath = resolver(imp.schemaLocation, imp.namespace);
    const importName = getImportName(imp.schemaLocation);
    importNames.push(importName);
    lines.push(`import ${importName} from '${importPath}';`);
  }
  lines.push('');

  // Build schema object (for JSON output)
  const elements: Record<string, unknown> = {};
  for (const [typeName, typeEl] of complexTypes) {
    elements[typeName] = generateElementObj(typeEl, complexTypes, simpleTypes);
  }

  const schema: Record<string, unknown> = {
    elements,
  };
  if (rootElement) {
    schema.root = rootElement.name;
  }
  if (targetNs) {
    schema.ns = targetNs;
    schema.prefix = prefix;
  }
  if (imports.length > 0) {
    schema.imports = imports;
  }

  // Schema definition - use export default for cleaner imports
  lines.push('export default {');
  if (targetNs) {
    lines.push(`  ns: '${targetNs}',`);
    lines.push(`  prefix: '${prefix}',`);
  }
  if (rootElement) {
    lines.push(`  root: '${rootElement.name}',`);
  }
  
  // Add include array if there are imports
  if (importNames.length > 0) {
    lines.push(`  include: [${importNames.join(', ')}],`);
  }
  
  lines.push('  elements: {');

  // Generate local element definitions
  for (const [typeName, typeEl] of complexTypes) {
    const elementDef = generateElementDef(typeEl, complexTypes, simpleTypes, '    ');
    lines.push(`    ${typeName}: ${elementDef},`);
  }

  lines.push('  },');
  lines.push('} as const satisfies XsdSchema;');
  lines.push('');

  return {
    code: lines.join('\n'),
    root: rootElement?.name || '',
    namespace: targetNs,
    schema,
  };
}

/**
 * Get import variable name from schemaLocation
 */
function getImportName(schemaLocation: string): string {
  // Extract filename without extension and capitalize
  const filename = schemaLocation.split('/').pop()?.replace(/\.xsd$/, '') || 'Schema';
  return filename.charAt(0).toUpperCase() + filename.slice(1);
}
