# ts-xsd Codegen Module

**Generate TypeScript from XSD** - Transform XSD schemas into type-safe TypeScript code.

## Overview

The codegen module provides tools to generate TypeScript code from XSD schema definitions:

| Generator | Output | Use Case |
|-----------|--------|----------|
| `generateSchemaLiteral` | Schema `as const` literal | Type inference with `InferSchema<T>` |
| `generateSchemaFile` | Complete TypeScript file | Standalone schema modules |
| `generateInterfaces` | TypeScript interfaces | Pre-computed types (avoids TS2589) |

## Why Code Generation?

### Problem: TypeScript Recursion Limits

TypeScript's type inference has depth limits. Complex schemas with many nested types can trigger:

```
TS2589: Type instantiation is excessively deep and possibly infinite.
```

### Solution: Build-Time Generation

Instead of relying on compile-time inference:

```typescript
// ❌ May hit recursion limits with complex schemas
type Data = InferSchema<typeof complexSchema>;
```

Generate interfaces at build time:

```typescript
// ✅ Pre-computed, no recursion limits
import type { AbapClass } from './generated/types';
```

## Schema Literal Generator

### `generateSchemaLiteral(xsd, options)`

Transforms XSD content into a TypeScript schema literal with `as const`.

```typescript
import { generateSchemaLiteral } from '@abapify/ts-xsd';

const xsd = `
  <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="person" type="PersonType"/>
    <xs:complexType name="PersonType">
      <xs:sequence>
        <xs:element name="name" type="xs:string"/>
        <xs:element name="age" type="xs:int" minOccurs="0"/>
      </xs:sequence>
    </xs:complexType>
  </xs:schema>
`;

const code = generateSchemaLiteral(xsd, {
  name: 'person',
  features: { $xmlns: true, $imports: true, $filename: true },
  exclude: ['annotation'],
});
```

**Output:**
```typescript
export const person = {
  $filename: "person.xsd",
  $xmlns: {
    xs: "http://www.w3.org/2001/XMLSchema",
  },
  element: [
    { name: "person", type: "PersonType" },
  ],
  complexType: [
    {
      name: "PersonType",
      sequence: {
        element: [
          { name: "name", type: "xs:string" },
          { name: "age", type: "xs:int", minOccurs: "0" },
        ],
      },
    },
  ],
} as const;
```

### Options

| Option | Type | Description |
|--------|------|-------------|
| `name` | `string` | Variable name for exported schema |
| `comment` | `string` | JSDoc comment |
| `pretty` | `boolean` | Pretty print with indentation (default: `true`) |
| `indent` | `string` | Indentation string (default: `'  '`) |
| `features` | `object` | Enable `$` extension properties |
| `exclude` | `string[]` | Property names to exclude |
| `importResolver` | `function` | Resolve import paths |

### Features

| Feature | Description |
|---------|-------------|
| `$xmlns` | Include namespace declarations |
| `$imports` | Convert `import` to linked schema references |
| `$filename` | Include source filename (enables backward rendering) |

## Schema File Generator

### `generateSchemaFile(xsd, options)`

Generates a complete TypeScript file with imports and type exports.

```typescript
import { generateSchemaFile } from '@abapify/ts-xsd';

const code = generateSchemaFile(xsd, {
  name: 'classes',
  features: { $xmlns: true, $imports: true, $filename: true },
  importResolver: (location) => {
    // adtcore.xsd → ./adtcore
    return './' + location.replace('.xsd', '');
  },
});
```

**Output:**
```typescript
/**
 * Auto-generated schema literal from XSD
 * 
 * DO NOT EDIT - Generated by ts-xsd codegen
 */

import { adtcore } from './adtcore';
import { abapoo } from './abapoo';

export const classes = {
  $filename: "classes.xsd",
  $xmlns: { ... },
  $imports: [adtcore, abapoo],
  targetNamespace: "http://www.sap.com/adt/oo/classes",
  // ...
} as const;

export type ClassesType = typeof classes;
```

## Interface Generator

### `generateInterfaces(schema, options)`

Generates TypeScript interfaces from a parsed schema. Uses `ts-morph` for AST manipulation.

```typescript
import { parseXsd, generateInterfaces } from '@abapify/ts-xsd';

const schema = parseXsd(xsdContent);
const interfaces = generateInterfaces(schema, {
  generateAllTypes: true,
  addJsDoc: true,
});
```

**Output:**
```typescript
/** Generated from complexType: PersonType */
export interface PersonType {
  name: string;
  age?: number;
}

/** Generated from complexType: AddressType */
export interface AddressType {
  street: string;
  city: string;
  country?: string;
}
```

### Options

| Option | Type | Description |
|--------|------|-------------|
| `rootElement` | `string` | Generate interface for specific element |
| `generateAllTypes` | `boolean` | Generate all complex/simple types |
| `addJsDoc` | `boolean` | Add JSDoc comments |

### Cross-Schema Type Resolution

The interface generator resolves types across linked schemas:

```typescript
// Schema with $imports
const schema = {
  $imports: [adtcore, abapoo],
  complexType: [{
    name: 'AbapClass',
    complexContent: {
      extension: { base: 'abapoo:AbapOoObject' }  // Resolved!
    }
  }]
};

const interfaces = generateInterfaces(schema, { generateAllTypes: true });
// Generates: interface AbapClass extends AbapOoObject { ... }
```

## Generator Presets

The `presets.ts` module provides composable generators for different output formats.

### Preset Architecture

```typescript
interface GeneratorContext {
  xsdContent: string;
  schema: Schema;
  name: string;
  tsImports: string[];
  importedSchemas: string[];
  outputSchema: Record<string, unknown>;
  options: PresetOptions;
}

type GeneratorFn = (ctx: GeneratorContext) => GeneratorContext;
```

### Built-in Transforms

| Transform | Description |
|-----------|-------------|
| `applyXmlns` | Include/exclude `$xmlns` |
| `applyImports` | Convert imports to schema references |
| `applyFilename` | Add `$filename` property |
| `applyExclude` | Filter excluded properties |

### Creating Custom Presets

```typescript
import { initContext, applyXmlns, applyImports } from '@abapify/ts-xsd/codegen/presets';

function myPreset(xsd: string, options: PresetOptions): string {
  let ctx = initContext(xsd, options);
  ctx = applyXmlns(ctx);
  ctx = applyImports(ctx);
  // Custom transforms...
  return generateOutput(ctx);
}
```

## Usage in adt-schemas

The codegen module powers the schema generation pipeline:

```
XSD Files (.xsd/model/)
    ↓ generateSchemaLiteral
Schema Literals (as const)
    ↓ generateInterfaces
TypeScript Interfaces (204 types)
    ↓ typed() wrapper
Typed Schemas (parse/build)
```

### Generation Script Example

```typescript
import { generateSchemaLiteral, generateInterfaces, parseXsd } from '@abapify/ts-xsd';
import { readFileSync, writeFileSync } from 'fs';

// 1. Generate schema literal
const xsd = readFileSync('classes.xsd', 'utf-8');
const schemaCode = generateSchemaLiteral(xsd, {
  name: 'classes',
  features: { $xmlns: true, $imports: true, $filename: true },
  exclude: ['annotation'],
  importResolver: (loc) => `./${loc.replace('.xsd', '')}`,
});
writeFileSync('schemas/classes.ts', schemaCode);

// 2. Generate interfaces
const schema = parseXsd(xsd);
const interfaces = generateInterfaces(schema, { generateAllTypes: true });
writeFileSync('types/classes.ts', interfaces);
```

## Best Practices

### 1. Always Enable `$filename`

Required for backward rendering (rebuilding XSD from schema):

```typescript
features: { $filename: true }
```

### 2. Exclude Annotations

Annotations add bulk without affecting type inference:

```typescript
exclude: ['annotation']
```

### 3. Use Import Resolver for Multi-Schema Projects

```typescript
importResolver: (schemaLocation) => {
  // Map XSD imports to TypeScript imports
  const name = schemaLocation.replace('.xsd', '');
  return `./schemas/${name}`;
}
```

### 4. Generate Interfaces for Complex Schemas

Avoid TypeScript recursion limits:

```typescript
// For schemas with 50+ types, generate interfaces
const interfaces = generateInterfaces(schema, { generateAllTypes: true });
```

### 5. Verify with Round-Trip Tests

Ensure generated schemas work correctly:

```typescript
import { parseXml, buildXml } from '@abapify/ts-xsd';
import { classes } from './generated/classes';

const data = parseXml(classes, xmlString);
const rebuilt = buildXml(classes, data);
// Verify rebuilt matches original structure
```

## CLI Usage

The codegen module includes a CLI for batch generation:

```bash
# Generate schema literal
npx ts-xsd codegen -i schema.xsd -o schema.ts

# With options
npx ts-xsd codegen -i schema.xsd -o schema.ts \
  --name mySchema \
  --features '$xmlns,$imports,$filename' \
  --exclude annotation
```

## Reference

- [ts-xsd README](../README.md)
- [ts-xsd AGENTS.md](../AGENTS.md)
- [adt-schemas](../../adt-schemas/README.md) - Real-world usage
