#!/usr/bin/env npx tsx
/**
 * Codegen script for adt-schemas
 * 
 * Generates TypeScript schema files from XSD using ts-xsd.
 * Processes .xsd files from both .xsd/sap/ and .xsd/custom/ directories.
 * 
 * Usage:
 *   npx tsx scripts/codegen.ts
 *   npx nx run adt-schemas:codegen
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'node:fs';
import { join, basename } from 'node:path';
// Import directly from presets file (not exported from package due to DTS bundling issues)
import { generateWithPreset } from '../../ts-xsd/src/codegen/presets';

// Schema sources
const SOURCES = {
  sap: {
    xsdDir: '.xsd/sap',
    outputDir: 'src/schemas/generated/schemas/sap',
    schemas: [
      // Base schemas
      'atom',
      'adtcore',
      'abapsource',
      
      // OO types
      'abapoo',
      'classes',
      'interfaces',
      
      // Packages
      'packagesV1',
      
      // ATC (ABAP Test Cockpit)
      'atc',
      'atcresult',
      'atcworklist',
      
      // Transport
      'transportmanagment',
      'transportsearch',
      
      // Configuration
      'configuration',
      'configurations',
      
      // Checks & Activation
      'checkrun',
      'checklist',
      
      // Debugging
      'debugger',
      'logpoint',
      'traces',
      
      // Refactoring
      'quickfixes',
      
      // Other
      'log',
      'templatelink',
    ],
  },
  custom: {
    xsdDir: '.xsd/custom',
    outputDir: 'src/schemas/generated/schemas/custom',
    schemas: [
      'atomExtended',
      'discovery',
      'Ecore',
      'http',
      'templatelinkExtended',
      'transportfind',
      'transportmanagment-create',
      'transportmanagment-single',
    ],
  },
};

// Build set of ALL schemas for import resolution
const ALL_SCHEMAS = new Set([
  ...SOURCES.sap.schemas,
  ...SOURCES.custom.schemas,
]);

interface GenerateOptions {
  sourceName: string;
  xsdDir: string;
  outputDir: string;
  schemas: string[];
  importResolver: (schemaLocation: string) => string | null;
}

function generateSchemas(options: GenerateOptions): { generated: string[]; failed: string[] } {
  const { sourceName, xsdDir, outputDir, schemas, importResolver } = options;
  mkdirSync(outputDir, { recursive: true });
  
  const generated: string[] = [];
  const failed: string[] = [];

  for (const schemaName of schemas) {
    const xsdPath = join(xsdDir, `${schemaName}.xsd`);
    
    if (!existsSync(xsdPath)) {
      console.log(`âš ï¸  [${sourceName}] Skipping ${schemaName} - XSD not found`);
      continue;
    }

    try {
      const xsdContent = readFileSync(xsdPath, 'utf-8');
      const tsContent = generateWithPreset(xsdContent, 'raw', {
        name: schemaName,
        comment: `Source: ${sourceName}/${basename(xsdPath)}`,
        features: { $xmlns: true, $imports: true, defaultImports: true },
        exclude: ['annotation'],
        importResolver,
      });

      const outputPath = join(outputDir, `${schemaName}.ts`);
      writeFileSync(outputPath, tsContent);
      console.log(`âœ… [${sourceName}] Generated ${schemaName}`);
      generated.push(schemaName);
    } catch (error) {
      console.error(`âŒ [${sourceName}] Failed ${schemaName}:`, error instanceof Error ? error.message : error);
      failed.push(schemaName);
    }
  }

  // Generate index.ts
  const indexLines = [
    '/**',
    ` * Auto-generated index for ${sourceName} XSD schemas`,
    ' * ',
    ' * DO NOT EDIT - Generated by ts-xsd codegen',
    ' */',
    '',
    ...generated.map(name => `export * from './${name}';`),
    '',
  ];
  writeFileSync(join(outputDir, 'index.ts'), indexLines.join('\n'));
  console.log(`âœ… [${sourceName}] Generated index.ts`);

  return { generated, failed };
}

function main() {
  let totalGenerated = 0;
  let totalFailed = 0;

  // Generate SAP schemas
  console.log('\nðŸ“¦ Generating SAP schemas...');
  const sapResult = generateSchemas({
    sourceName: 'sap',
    xsdDir: SOURCES.sap.xsdDir,
    outputDir: SOURCES.sap.outputDir,
    schemas: SOURCES.sap.schemas,
    importResolver: (schemaLocation: string) => {
      const importName = schemaLocation.replace(/\.xsd$/, '');
      if (SOURCES.sap.schemas.includes(importName)) {
        return `./${importName}`;
      }
      // Check if it's a custom schema
      if (SOURCES.custom.schemas.includes(importName)) {
        return `../custom/${importName}`;
      }
      return null;
    },
  });
  totalGenerated += sapResult.generated.length;
  totalFailed += sapResult.failed.length;

  // Generate custom schemas
  console.log('\nðŸ“¦ Generating custom schemas...');
  const customResult = generateSchemas({
    sourceName: 'custom',
    xsdDir: SOURCES.custom.xsdDir,
    outputDir: SOURCES.custom.outputDir,
    schemas: SOURCES.custom.schemas,
    importResolver: (schemaLocation: string) => {
      // Extract basename without path and extension (e.g., "../sap/adtcore.xsd" -> "adtcore")
      const importName = schemaLocation.replace(/\.xsd$/, '').replace(/^.*\//, '');
      if (SOURCES.custom.schemas.includes(importName)) {
        return `./${importName}`;
      }
      // Check if it's a SAP schema
      if (SOURCES.sap.schemas.includes(importName)) {
        return `../sap/${importName}`;
      }
      return null;
    },
  });
  totalGenerated += customResult.generated.length;
  totalFailed += customResult.failed.length;

  // Generate schemas/index.ts (not the root generated/index.ts which has typed schemas)
  const schemasIndexLines = [
    '/**',
    ' * Auto-generated index for raw schema literals',
    ' * ',
    ' * DO NOT EDIT - Generated by ts-xsd codegen',
    ' */',
    '',
    '// SAP schemas',
    `export * from './sap';`,
    '',
    '// Custom schemas',
    `export * from './custom';`,
    '',
  ];
  mkdirSync('src/schemas/generated/schemas', { recursive: true });
  writeFileSync('src/schemas/generated/schemas/index.ts', schemasIndexLines.join('\n'));
  console.log(`\nâœ… Generated schemas/index.ts`);

  console.log(`\nðŸ“Š Summary: ${totalGenerated} schemas generated, ${totalFailed} failed`);
  
  if (totalFailed > 0) {
    process.exit(1);
  }
}

main();
