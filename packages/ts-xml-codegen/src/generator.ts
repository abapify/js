/**
 * XSD to ts-xml Schema Generator
 *
 * Generates TypeScript code with ts-xml schemas from parsed XSD
 */

import type {
  XsdSchema,
  XsdComplexType,
  XsdSimpleType,
  XsdElement,
  XsdAttribute,
  XsdSequence,
  XsdChoice,
} from 'ts-xml-xsd';

export interface GeneratorOptions {
  /** Namespace prefix to use in generated code */
  prefix?: string;
  /** Whether to export types */
  exportTypes?: boolean;
  /** Whether to include JSDoc comments */
  includeComments?: boolean;
}


/**
 * Generate ts-xml schema code from parsed XSD
 */
export function generateTsXmlSchemas(
  schema: XsdSchema,
  options: GeneratorOptions = {}
): string {
  const {
    prefix = extractPrefix(schema.targetNamespace),
    exportTypes = true,
    includeComments = true,
  } = options;

  const lines: string[] = [];

  // Header
  lines.push('/**');
  lines.push(' * Auto-generated ts-xml schemas from XSD');
  if (schema.targetNamespace) {
    lines.push(` * Namespace: ${schema.targetNamespace}`);
  }
  lines.push(' * Generated by ts-xml-codegen');
  lines.push(' */');
  lines.push('');
  lines.push("import { tsxml, type InferSchema } from 'ts-xml';");
  lines.push('');

  // Namespace constant
  if (schema.targetNamespace) {
    lines.push(`/** Target namespace */`);
    lines.push(`export const NS = '${schema.targetNamespace}';`);
    lines.push(`export const PREFIX = '${prefix}';`);
    lines.push('');
  }

  // Analyze dependencies and order types
  const typeMap = new Map<string, XsdComplexType | XsdSimpleType>();
  for (const ct of schema.complexTypes) {
    if (ct.name) typeMap.set(ct.name, ct);
  }
  for (const st of schema.simpleTypes) {
    if (st.name) typeMap.set(st.name, st);
  }

  // Generate simple types first (enums)
  for (const simpleType of schema.simpleTypes) {
    if (!simpleType.name) continue;
    const code = generateSimpleType(simpleType, prefix, includeComments);
    lines.push(code);
    lines.push('');
  }

  // Generate complex types (topologically sorted would be better, but for now just generate)
  for (const complexType of schema.complexTypes) {
    if (!complexType.name) continue;
    const code = generateComplexType(complexType, prefix, schema.targetNamespace, includeComments);
    lines.push(code);
    lines.push('');
  }

  // Generate root element schemas
  for (const element of schema.elements) {
    if (!element.name) continue;
    const code = generateRootElement(element, prefix, schema.targetNamespace, includeComments);
    lines.push(code);
    lines.push('');
  }

  // Export types
  if (exportTypes) {
    lines.push('// Type exports');
    for (const ct of schema.complexTypes) {
      if (ct.name) {
        const schemaName = toSchemaName(ct.name);
        const typeName = ct.name;
        lines.push(`export type ${typeName} = InferSchema<typeof ${schemaName}>;`);
      }
    }
  }

  return lines.join('\n');
}

/**
 * Generate code for a simpleType (usually enum)
 */
function generateSimpleType(
  simpleType: XsdSimpleType,
  prefix: string,
  includeComments: boolean
): string {
  const lines: string[] = [];
  const name = simpleType.name!;

  if (simpleType.restriction?.enumerations?.length) {
    // Generate as union type
    const values = simpleType.restriction.enumerations.map((e: { value: string }) => `'${e.value}'`);
    
    if (includeComments) {
      lines.push(`/** ${name} enum values */`);
    }
    lines.push(`export type ${name} = ${values.join(' | ')};`);
    
    // Also generate array of values for runtime use
    lines.push(`export const ${name}Values = [${values.join(', ')}] as const;`);
  }

  return lines.join('\n');
}

/**
 * Generate code for a complexType
 */
function generateComplexType(
  complexType: XsdComplexType,
  prefix: string,
  namespace: string | undefined,
  includeComments: boolean
): string {
  const lines: string[] = [];
  const name = complexType.name!;
  const schemaName = toSchemaName(name);

  if (includeComments) {
    lines.push(`/** ${name} schema */`);
  }

  lines.push(`export const ${schemaName} = tsxml.schema({`);
  lines.push(`  tag: '${prefix}:${camelToKebab(name)}',`);
  
  if (namespace) {
    lines.push(`  ns: { ${prefix}: NS },`);
  }

  lines.push('  fields: {');

  // Handle different content models
  if (complexType.sequence) {
    const fieldLines = generateSequenceFields(complexType.sequence, prefix);
    lines.push(...fieldLines.map(l => '    ' + l));
  } else if (complexType.choice) {
    const fieldLines = generateChoiceFields(complexType.choice, prefix);
    lines.push(...fieldLines.map(l => '    ' + l));
  } else if (complexType.complexContent?.extension) {
    // Type extension - include base type reference
    const ext = complexType.complexContent.extension;
    lines.push(`    // Extends: ${ext.base}`);
    if (ext.sequence) {
      const fieldLines = generateSequenceFields(ext.sequence, prefix);
      lines.push(...fieldLines.map(l => '    ' + l));
    }
  }

  // Attributes
  for (const attr of complexType.attributes) {
    const fieldLine = generateAttributeField(attr, prefix);
    lines.push('    ' + fieldLine);
  }

  lines.push('  },');
  lines.push('} as const);');

  return lines.join('\n');
}

/**
 * Generate fields for a sequence
 */
function generateSequenceFields(sequence: XsdSequence, prefix: string): string[] {
  const lines: string[] = [];

  for (const elem of sequence.elements) {
    const fieldLine = generateElementField(elem, prefix);
    lines.push(fieldLine);
  }

  return lines;
}

/**
 * Generate fields for a choice
 */
function generateChoiceFields(choice: XsdChoice, prefix: string): string[] {
  const lines: string[] = [];
  lines.push('// Choice - one of:');

  for (const elem of choice.elements) {
    const fieldLine = generateElementField(elem, prefix, true);
    lines.push(fieldLine);
  }

  return lines;
}

/**
 * Generate a single element field
 */
function generateElementField(elem: XsdElement, prefix: string, optional = false): string {
  // Handle ref elements (e.g., ref="other:element")
  if (elem.ref && !elem.name) {
    const refName = extractLocalName(elem.ref);
    const fieldName = toCamelCase(refName);
    const isOptional = optional || elem.minOccurs === '0';
    const isArray = elem.maxOccurs === 'unbounded' || (elem.maxOccurs && parseInt(elem.maxOccurs) > 1);
    const kind = isArray ? 'elems' : 'elem';
    
    // Reference to external schema - generate a comment
    let fieldDef = `{ kind: '${kind}', name: '${elem.ref}', type: 'string' /* TODO: import from ${elem.ref} */`;
    if (isOptional) {
      fieldDef += ', optional: true';
    }
    fieldDef += ' },';
    return `${fieldName}: ${fieldDef}`;
  }

  const name = elem.name!;
  const fieldName = toCamelCase(name);
  const isOptional = optional || elem.minOccurs === '0';
  const isArray = elem.maxOccurs === 'unbounded' || (elem.maxOccurs && parseInt(elem.maxOccurs) > 1);

  const kind = isArray ? 'elems' : 'elem';
  const type = elem.type || 'xsd:string';

  // Check if it's a primitive type
  const isPrimitive = type.startsWith('xsd:') || type.startsWith('xs:');

  let fieldDef: string;
  if (isPrimitive) {
    const tsType = xsdTypeToTsXml(type);
    fieldDef = `{ kind: '${kind}', name: '${prefix}:${name}', type: '${tsType}'`;
  } else {
    // Reference to another schema
    const refSchemaName = toSchemaName(extractLocalName(type));
    fieldDef = `{ kind: '${kind}', name: '${prefix}:${name}', schema: ${refSchemaName}`;
  }

  if (isOptional) {
    fieldDef += ', optional: true';
  }
  fieldDef += ' },';

  return `${fieldName}: ${fieldDef}`;
}

/**
 * Generate an attribute field
 */
function generateAttributeField(attr: XsdAttribute, prefix: string): string {
  const name = attr.name!;
  const fieldName = toCamelCase(name);
  const type = attr.type || 'xsd:string';
  const tsType = xsdTypeToTsXml(type);
  const isOptional = attr.use !== 'required';

  let fieldDef = `{ kind: 'attr', name: '${prefix}:${name}', type: '${tsType}'`;
  if (isOptional) {
    fieldDef += ', optional: true';
  }
  fieldDef += ' },';

  return `${fieldName}: ${fieldDef}`;
}

/**
 * Generate root element schema
 */
function generateRootElement(
  element: XsdElement,
  prefix: string,
  namespace: string | undefined,
  includeComments: boolean
): string {
  const lines: string[] = [];
  const name = element.name!;
  const schemaName = toSchemaName(name) + 'RootSchema';

  if (includeComments) {
    lines.push(`/** Root element: ${name} */`);
  }

  if (element.type) {
    // Reference to a type
    const typeSchemaName = toSchemaName(extractLocalName(element.type));
    lines.push(`export const ${schemaName} = ${typeSchemaName};`);
  } else {
    // Inline definition (rare for root elements)
    lines.push(`export const ${schemaName} = tsxml.schema({`);
    lines.push(`  tag: '${prefix}:${name}',`);
    if (namespace) {
      lines.push(`  ns: { ${prefix}: NS },`);
    }
    lines.push('  fields: {},');
    lines.push('} as const);');
  }

  return lines.join('\n');
}

// =============================================================================
// Utility Functions
// =============================================================================

function extractPrefix(namespace: string | undefined): string {
  if (!namespace) return 'ns';
  
  // Try to extract from namespace URL
  const parts = namespace.split('/');
  const last = parts[parts.length - 1];
  
  // Common patterns
  if (last.length <= 10 && /^[a-z]+$/i.test(last)) {
    return last.toLowerCase();
  }
  
  return 'ns';
}

function extractLocalName(qname: string): string {
  const colonIndex = qname.indexOf(':');
  return colonIndex >= 0 ? qname.substring(colonIndex + 1) : qname;
}

function toSchemaName(typeName: string): string {
  return typeName + 'Schema';
}

function toCamelCase(str: string): string {
  // Already camelCase or lowercase
  if (/^[a-z]/.test(str)) return str;
  // PascalCase -> camelCase
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function camelToKebab(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

function xsdTypeToTsXml(xsdType: string): string {
  const localType = extractLocalName(xsdType);
  
  switch (localType) {
    case 'string':
    case 'normalizedString':
    case 'token':
    case 'NMTOKEN':
    case 'Name':
    case 'NCName':
    case 'ID':
    case 'IDREF':
    case 'anyURI':
    case 'language':
      return 'string';
    
    case 'int':
    case 'integer':
    case 'long':
    case 'short':
    case 'byte':
    case 'decimal':
    case 'float':
    case 'double':
    case 'positiveInteger':
    case 'negativeInteger':
    case 'nonPositiveInteger':
    case 'nonNegativeInteger':
    case 'unsignedInt':
    case 'unsignedLong':
    case 'unsignedShort':
    case 'unsignedByte':
      return 'number';
    
    case 'boolean':
      return 'boolean';
    
    case 'date':
    case 'dateTime':
    case 'time':
      return 'date';
    
    default:
      return 'string';
  }
}
