#!/usr/bin/env npx tsx
/**
 * Generate typed schema wrappers
 * 
 * Creates a typed/index.ts that re-exports schemas with pre-computed types.
 * This connects the runtime schema literals with the generated TypeScript interfaces.
 * 
 * Usage:
 *   npx tsx scripts/generate-typed-schemas.ts
 */

import { writeFileSync, mkdirSync, readdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

// Schema to root type mapping
// Maps schema name to the PREFIXED root element's type name
// Type names are prefixed with their namespace (e.g., AdtObject -> AdtcoreAdtObject)
// Only include schemas that exist and have matching types
const SCHEMA_ROOT_TYPES: Record<string, { type: string; dir: 'sap' | 'custom' }> = {
  // SAP schemas - core (prefix: Atom, Adtcore, Abapsource, Abapoo)
  atom: { type: 'AtomLinkType', dir: 'sap' },
  adtcore: { type: 'AdtcoreAdtObject', dir: 'sap' },
  abapsource: { type: 'AbapsourceAbapSourceObject', dir: 'sap' },
  abapoo: { type: 'AbapooAbapOoObject', dir: 'sap' },
  
  // SAP schemas - object types (prefix: Class, Intf, Pak)
  classes: { type: 'ClassAbapClass', dir: 'sap' },
  interfaces: { type: 'IntfAbapInterface', dir: 'sap' },
  packagesV1: { type: 'PakPackage', dir: 'sap' },
  
  // SAP schemas - ATC (prefix: Atc, AtcResult, AtcWorklist)
  // Note: atc and atcresult schemas don't define AtcWorklist - they define other types
  // atcworklist schema defines the main AtcWorklist type
  atcworklist: { type: 'AtcWorklistAtcWorklist', dir: 'sap' },
  
  // SAP schemas - config (prefix: Configuration, Config)
  configuration: { type: 'ConfigurationConfiguration', dir: 'sap' },
  configurations: { type: 'ConfigConfigurations', dir: 'sap' },
  
  // SAP schemas - checks (prefix: Checklist)
  checklist: { type: 'ChecklistMessageList', dir: 'sap' },
  
  // SAP schemas - debug (prefix: Logpoint, Traces)
  logpoint: { type: 'LogpointAdtLogpoint', dir: 'sap' },
  traces: { type: 'TracesTraces', dir: 'sap' },
  
  // SAP schemas - other (prefix: Quickfix, Compat)
  // quickfixes doesn't have AtcQuickfixes - removed
  templatelink: { type: 'CompatLinkType', dir: 'sap' },
  
  // Custom schemas (prefix: CompatExt, Http, Asx, TmCreate, TmSingle)
  templatelinkExtended: { type: 'CompatExtTemplateLinksType', dir: 'custom' },
  http: { type: 'HttpSessionType', dir: 'custom' },
  transportfind: { type: 'AsxAbapType', dir: 'custom' },
  'transportmanagment-create': { type: 'TmCreateRootType', dir: 'custom' },
  'transportmanagment-single': { type: 'TmSingleRoot', dir: 'custom' },
};

// Reserved words that can't be used as variable names
const RESERVED_WORDS = new Set(['debugger', 'class', 'interface', 'package', 'function', 'return', 'import', 'export']);

function toExportName(schemaName: string): string {
  // Convert schema name to valid JS identifier
  const name = schemaName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  // Handle reserved words by adding 'Schema' suffix
  if (RESERVED_WORDS.has(name)) {
    return name + 'Schema';
  }
  return name;
}

function main() {
  console.log('ðŸ”§ Generating typed schema wrappers...\n');
  
  const outputDir = 'src/schemas/generated';
  mkdirSync(outputDir, { recursive: true });
  
  // Read available types from generated/types/index.ts
  const typesContent = readFileSync('src/schemas/generated/types/index.ts', 'utf-8');
  const availableTypes = new Set<string>();
  const typePattern = /export (?:interface|type) (\w+)/g;
  let match;
  while ((match = typePattern.exec(typesContent)) !== null) {
    availableTypes.add(match[1]);
  }
  console.log(`ðŸ“Š Found ${availableTypes.size} available types`);
  
  // Filter schemas to only those with available types
  const validSchemas: Array<[string, { type: string; dir: 'sap' | 'custom' }]> = [];
  const skipped: string[] = [];
  
  for (const [schemaName, config] of Object.entries(SCHEMA_ROOT_TYPES)) {
    const schemaPath = `src/schemas/generated/schemas/${config.dir}/${schemaName}.ts`;
    if (!existsSync(schemaPath)) {
      skipped.push(`${schemaName} (no schema file)`);
      continue;
    }
    if (!availableTypes.has(config.type)) {
      skipped.push(`${schemaName} (type ${config.type} not found)`);
      continue;
    }
    validSchemas.push([schemaName, config]);
  }
  
  if (skipped.length > 0) {
    console.log(`âš ï¸  Skipped ${skipped.length} schemas:`);
    skipped.forEach(s => console.log(`   - ${s}`));
    console.log('');
  }
  
  const lines: string[] = [
    '/**',
    ' * Typed Schema Wrappers',
    ' * ',
    ' * DO NOT EDIT - Generated by generate-typed-schemas.ts',
    ' * ',
    ' * These schemas have pre-computed types that avoid TypeScript recursion limits.',
    ' * Use these instead of the raw schemas for full type safety.',
    ' * ',
    ' * @example',
    ' * import { classes } from \'@abapify/adt-schemas-xsd-v2/typed\';',
    ' * const data = classes.parse(xml);  // data is typed as AbapClass',
    ' */',
    '',
    '// Import the typed schema factory',
    'import { typed } from \'../../speci\';',
    '',
    '// Import raw schemas',
  ];
  
  // Import raw schemas (default exports) - prefix with _ to avoid name collision with typed exports
  for (const [schemaName, config] of validSchemas) {
    // Convert hyphenated names to camelCase for valid JS identifiers
    const importAlias = '_' + schemaName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    lines.push(`import ${importAlias} from './schemas/${config.dir}/${schemaName}';`);
  }
  
  // Collect unique type names
  const typeNames = new Set<string>();
  for (const [, config] of validSchemas) {
    typeNames.add(config.type);
  }
  
  lines.push('');
  lines.push('// Import generated types');
  lines.push('import type {');
  lines.push('  ' + Array.from(typeNames).sort().join(',\n  '));
  lines.push('} from \'./types\';');
  
  lines.push('');
  lines.push('// Re-export all types');
  lines.push('export * from \'./types\';');
  
  lines.push('');
  lines.push('// ============================================================================');
  lines.push('// TYPED SCHEMAS');
  lines.push('// ============================================================================');
  lines.push('');
  
  // Generate typed schema exports
  for (const [schemaName, config] of validSchemas) {
    const exportName = toExportName(schemaName);
    // Use same camelCase conversion as import alias
    const importAlias = '_' + schemaName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    lines.push(`/** ${schemaName} schema with ${config.type} type */`);
    lines.push(`export const ${exportName} = typed<${config.type}>(${importAlias});`);
    lines.push('');
  }
  
  // Write the file
  const outputPath = join(outputDir, 'index.ts');
  writeFileSync(outputPath, lines.join('\n'));
  console.log(`âœ… Generated ${outputPath}`);
  console.log(`ðŸ“Š ${validSchemas.length} typed schemas`);
}

main();
