#!/usr/bin/env npx tsx
/**
 * Generate typed schema wrappers
 * 
 * Creates a typed/index.ts that re-exports schemas with pre-computed types.
 * This connects the runtime schema literals with the generated TypeScript interfaces.
 * 
 * Usage:
 *   npx tsx scripts/generate-typed-schemas.ts
 */

import { writeFileSync, mkdirSync, readdirSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';

// Schema to root type mapping
// Maps schema name to the root element's type name (PascalCase)
// Only include schemas that exist and have matching types
const SCHEMA_ROOT_TYPES: Record<string, { type: string; dir: 'sap' | 'custom' }> = {
  // SAP schemas - core
  atom: { type: 'LinkType', dir: 'sap' },
  adtcore: { type: 'AdtObject', dir: 'sap' },
  abapsource: { type: 'AbapSourceObject', dir: 'sap' },
  abapoo: { type: 'AbapOoObject', dir: 'sap' },
  
  // SAP schemas - object types
  classes: { type: 'AbapClass', dir: 'sap' },
  interfaces: { type: 'AbapInterface', dir: 'sap' },
  packagesV1: { type: 'Package', dir: 'sap' },
  
  // SAP schemas - ATC
  atc: { type: 'AtcWorklist', dir: 'sap' },
  atcresult: { type: 'AtcWorklist', dir: 'sap' },
  atcworklist: { type: 'AtcWorklist', dir: 'sap' },
  
  // SAP schemas - config
  configuration: { type: 'Configuration', dir: 'sap' },
  configurations: { type: 'Configurations', dir: 'sap' },
  
  // SAP schemas - checks
  checklist: { type: 'CheckMessageList', dir: 'sap' },
  
  // SAP schemas - debug
  logpoint: { type: 'AdtLogpoint', dir: 'sap' },
  traces: { type: 'Traces', dir: 'sap' },
  
  // SAP schemas - other
  quickfixes: { type: 'AtcQuickfixes', dir: 'sap' },
  templatelink: { type: 'LinkType', dir: 'sap' },
  
  // Custom schemas
  templatelinkExtended: { type: 'TemplateLinksType', dir: 'custom' },
  transportfind: { type: 'Abap', dir: 'custom' },
  // Transport management - types not fully generated, using available types
  'transportmanagment-create': { type: 'RootType', dir: 'custom' },
  'transportmanagment-single': { type: 'unknown', dir: 'custom' },  // Root type is empty in generated types
};

// Reserved words that can't be used as variable names
const RESERVED_WORDS = new Set(['debugger', 'class', 'interface', 'package', 'function', 'return', 'import', 'export']);

function toExportName(schemaName: string): string {
  // Convert schema name to valid JS identifier
  const name = schemaName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  // Handle reserved words by adding 'Schema' suffix
  if (RESERVED_WORDS.has(name)) {
    return name + 'Schema';
  }
  return name;
}

function main() {
  console.log('ðŸ”§ Generating typed schema wrappers...\n');
  
  const outputDir = 'src/schemas/generated';
  mkdirSync(outputDir, { recursive: true });
  
  // Read available types from generated/types/index.ts
  const typesContent = readFileSync('src/schemas/generated/types/index.ts', 'utf-8');
  const availableTypes = new Set<string>();
  const typePattern = /export (?:interface|type) (\w+)/g;
  let match;
  while ((match = typePattern.exec(typesContent)) !== null) {
    availableTypes.add(match[1]);
  }
  console.log(`ðŸ“Š Found ${availableTypes.size} available types`);
  
  // Filter schemas to only those with available types
  const validSchemas: Array<[string, { type: string; dir: 'sap' | 'custom' }]> = [];
  const skipped: string[] = [];
  
  for (const [schemaName, config] of Object.entries(SCHEMA_ROOT_TYPES)) {
    const schemaPath = `src/schemas/generated/schemas/${config.dir}/${schemaName}.ts`;
    if (!existsSync(schemaPath)) {
      skipped.push(`${schemaName} (no schema file)`);
      continue;
    }
    if (!availableTypes.has(config.type)) {
      skipped.push(`${schemaName} (type ${config.type} not found)`);
      continue;
    }
    validSchemas.push([schemaName, config]);
  }
  
  if (skipped.length > 0) {
    console.log(`âš ï¸  Skipped ${skipped.length} schemas:`);
    skipped.forEach(s => console.log(`   - ${s}`));
    console.log('');
  }
  
  const lines: string[] = [
    '/**',
    ' * Typed Schema Wrappers',
    ' * ',
    ' * DO NOT EDIT - Generated by generate-typed-schemas.ts',
    ' * ',
    ' * These schemas have pre-computed types that avoid TypeScript recursion limits.',
    ' * Use these instead of the raw schemas for full type safety.',
    ' * ',
    ' * @example',
    ' * import { classes } from \'@abapify/adt-schemas-xsd-v2/typed\';',
    ' * const data = classes.parse(xml);  // data is typed as AbapClass',
    ' */',
    '',
    '// Import the typed schema factory',
    'import { typed } from \'../../speci\';',
    '',
    '// Import raw schemas',
  ];
  
  // Import raw schemas (default exports) - prefix with _ to avoid name collision with typed exports
  for (const [schemaName, config] of validSchemas) {
    // Convert hyphenated names to camelCase for valid JS identifiers
    const importAlias = '_' + schemaName.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
    lines.push(`import ${importAlias} from './schemas/${config.dir}/${schemaName}';`);
  }
  
  // Collect unique type names
  const typeNames = new Set<string>();
  for (const [, config] of validSchemas) {
    typeNames.add(config.type);
  }
  
  lines.push('');
  lines.push('// Import generated types');
  lines.push('import type {');
  lines.push('  ' + Array.from(typeNames).sort().join(',\n  '));
  lines.push('} from \'./types\';');
  
  lines.push('');
  lines.push('// Re-export all types');
  lines.push('export * from \'./types\';');
  
  lines.push('');
  lines.push('// ============================================================================');
  lines.push('// TYPED SCHEMAS');
  lines.push('// ============================================================================');
  lines.push('');
  
  // Generate typed schema exports
  for (const [schemaName, config] of validSchemas) {
    const exportName = toExportName(schemaName);
    lines.push(`/** ${schemaName} schema with ${config.type} type */`);
    lines.push(`export const ${exportName} = typed<${config.type}>(_${schemaName});`);
    lines.push('');
  }
  
  // Write the file
  const outputPath = join(outputDir, 'index.ts');
  writeFileSync(outputPath, lines.join('\n'));
  console.log(`âœ… Generated ${outputPath}`);
  console.log(`ðŸ“Š ${validSchemas.length} typed schemas`);
}

main();
